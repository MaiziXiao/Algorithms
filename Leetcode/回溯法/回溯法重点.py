# 回溯法一般步骤
# 1. 定义一个解空间（子集树、排列树二选一）
# 2. 利用适于搜索的方法组织解空间。确定解的编码及解的长度是否固定。若解的长度固定，那么x[k] = i。若解的长度不固定，那么x.append(i) ... x.pop(i)
# 3. 利用深度优先法搜索解空间。
# 4. 利用剪枝函数避免移动到不可能产生解的子空间。约束函数：是否满足显约束（存在）限界函数： 是否满足隐约束（最优）
# https://zhuanlan.zhihu.com/p/51882471

######################################子集树###################################################
# 当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树成为子集树。子集树有2^n个叶节点
# i.e.［1,2,3] 的全部子集
#               [0]                           [1]
#      [0,0]          [0,1]           [1,0]          [1,1]
# [0,0,0][0,0,1] [0,1,0][0,1,1] [1,0,0][1,0,1] [1,1,0][1,1,1]

# 子集树递归模板
# https://www.okcode.net/article/40919
# 递归函数的参数随着每次递归改变, 在这里理解为list里搜索的index
# 如果当前操作行不通，如何回溯到上一步操作。所以也要保存其上一步操作的值!!!!
a = [1, 2, 3, 4]
subset_list = []   # 一组解
subset = []  # 一个解，用于存放a[i]的选择状态：1-选择，0-不选
target = 3  # 约束条件


def conflict(k, subset: list):
    """
    约束函数
    """
    if k == 0:
        return True
    # 根据部分解，构造部分集
    s = [x[0] for x in filter(lambda x: x[1] != 0, zip(a[:k + 1], subset[:k + 1]))]
    if sum(s) < target:
        return True
    return False


def dfs(k):
    """
    :param k: 第 k 个元素
    """
    # 当已经到树最底层的叶支点
    if k == len(a):
        print(subset)
        subset_list.append([a[k] for k,v in enumerate(subset) if v != 0])  # 保存一个子集, subset is mask
    else:
        for i in range(2):  # 遍历元素 a[k] 的两种选择状态:1-选择，0-不选
            subset.append(i)
            if conflict(k, subset):   # 剪枝!!!!! 约束函数
                dfs(k + 1)
            subset.pop()    # 回溯!!!!!!!最重要的一步  把数字pop了以后就可以回上一层

dfs(0)
print(subset_list)

######################################排列树###################################################
# 当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有n!个叶节点。
# i.e. [1,2,3]的全排列。 3*2*1=6叶节点
#           [1]                [2]               [3]
#      [1,2] [1,3]         [2,1][2,3]        [3,1][3,2]
#    [1,2,3]  [1,3,2]   [2,1,3] [2,3,1]    [3,1,2] [3,2,1]
