from typing import List

class Solution:
    def singleNumbers(self, nums: List[int]) -> List[int]:
        """
        一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
        """
        # nums.sort()
        # i = 0
        # res = []
        # while i < len(nums)-1:
        #     print(i)
        #     if nums[i] == nums[i+1]:
        #         i += 2
        #     else:
        #         res.append(nums[i])
        #         i += 1
        # if len(res) == 1:
        #     res.append(nums[-1])
        # return res

        # 位运算
        # 相同的数异或为0，不同的异或为1
        # 任何一个数字异或它自己都等于0，任何一个数字和0异或等于它本身

        # 所以，数组里面所有数异或 = 目标两个数异或 。 由于这两个数不同，所以异或结果必然不为0。
        # 假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的
        # 那么可以根据数组里面所有数的第二位为0或者1将数组划分为2个。
        # 这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。
        # 这两个数组里面的数各自进行异或，得到的结果就是答案
        # & （与）：真真为真，一假为假（一为0，则为0）（例如：  0011 & 0101 = 0001）
        # | （或）：一真为真，假假为假（一为1，则为1）（例如：  0011 | 0101 = 0111）
        # ~（非）：真为假，假为真（~0011 = 1100）
        # ^ （异或）：不同为真，相同为假（例如：  0011 | 0101 = 1001）
        # << （左移）：二进制向左移动一位，末尾补0
        # >> （右移）：  二进制向右移动一位
        # 101101 >> 1
        # 101101->10110
        xor = 0
        # 两个数字异或结果
        for num in nums:
            xor ^= num
        # 最末尾的 1 从右向左边数在第几位
        counter = 0
        while xor & 1 == 0:
            xor >>= 1
            counter += 1

        res = [0, 0]
        for num in nums:
            # 以最后不同的一位把原数组分成两个分数组
            if (num >> counter) & 1 == 1:
                res[1] ^= num
            else:
                res[0] ^= num
        return res

Solution().singleNumbers([4,1,4,6])