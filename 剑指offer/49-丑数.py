import heapq
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        """
        我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

        示例:

        输入: n = 10
        输出: 12
        解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
        1，1*2，1*3，2*2，5， 2*3， 2*2*2，3*3*3，2*5， 2*2*3
        说明:  

        1 是丑数。
        n 不超过1690。
        """
        # 既然求第n小的丑数，可以采用最小堆来解决。每次弹出堆中最小的丑数，然后检查它分别乘以2、3 和 5
        # 后的数是否生成过，如果是第一次生成，那么就放入堆中。第n个弹出的数即为第n小的丑数。
        q = [1]
        for _ in range(1, n):
            val = heapq.heappop(q)
            while q and q[0] == val:
                heapq.heappop(q)
            for i in [2, 3, 5]:
            	heapq.heappush(q, i*val)

        return q[0]


        # 我们知道，丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是： A：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......}
        #
        # B：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}
        #
        # C：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}
        #
        # 那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。
        #
        # 合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。
        #
        # 回到本题，要求丑数ugly数组中的第n项，而目前只知道ugly[0]=1，所以此时三个有序链表分别就只有一个元素：
        #
        # A ： {1*2......}
        #
        # B ： {1*3......}
        #
        # C ：{1*5......}
        #
        # 假设三个数组的指针分别是i,j,k，此时均是指向第一个元素，然后比较A[i]，B[j]和C[k]，得到的最小的数A[i]，就是ugly[1]，此时ugly就变成{1,2}了，对应的ABC数组就分别变成了：
        #
        # A ： {1*2，2*2......}
        #
        # B ： {1*3, 2*3......}
        #
        # C ：{1*5,2*5......}
        #
        # 此时根据合并有序数组的原理，A数组指针i就指向了下一个元素，即'2*2'，而j和k依然分别指向B[0]和C[0]，然后进行下一轮合并，就是A[1]和B[0]和C[0]比较，最小值作为ugly[2].....如此循环n次，就可以得到ugly[n]了。
        #
        # 此外，注意到ABC三个数组实际上就是ugly[]*2，ugly[]*3和ugly[]*5的结果，所以每次只需要比较A[i]=ugly[i]*2，B[j]=ugly[j]*3和C[k]=ugly[k]*5的大小即可。然后谁最小，就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。
        res = [1] * n
        idx3, idx5, idx7 = 0, 0, 0
        for i in range(1, n):
            res[i] = min(res[idx3] * 3, res[idx5] * 5, res[idx7] * 7)
            if res[i] == res[idx3] * 3: idx3 += 1
            if res[i] == res[idx5] * 5: idx5 += 1
            if res[i] == res[idx7] * 7: idx7 += 1
        return res[k - 1]

Solution().nthUglyNumber(15)