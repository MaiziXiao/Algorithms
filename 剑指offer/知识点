1. 二叉树
    先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)
    中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)
    后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)
    先序遍历：在第一次遍历到节点时就执行操作，一般只是想遍历执行操作（或输出结果）可选用先序遍历；
    中序遍历：对于二分搜索树，中序遍历的操作顺序（或输出结果顺序）是符合从小到大（或从大到小）顺序的，故要遍历输出排序好的结果需要使用中序遍历
    后序遍历：后续遍历的特点是执行操作时，肯定已经遍历过该节点的左右子节点，故适用于要进行破坏性操作的情况，比如删除所有节点
    重建二叉树： https://zhuanlan.zhihu.com/p/73438175
        # 递归的函数要干什么？
        # 递归停止的条件是什么？
        # 从某层到下一层的关系是什么？
2. 二分法
    https://zhuanlan.zhihu.com/p/86520559

3.位运算
输出一个整数的各个位
        res = []
        while n > 0:
            left = n%10
            res.append(left)
            n = (n-left)//10
        print(res)
        return res

4回溯法模板
    def dfs(target, begin, path):
        # 结束条件
        if target == 0:
            if path not in res:
               # python的话一定要加: 才是复制，否则后续操作会修改
                res.append(path[:])
            return
        for i in range(begin, len(candidates)):
            rediduel = target - candidates[i]
           # 减枝条件
            if rediduel < 0:
                break
            path.append(candidates[i])
            dfs(rediduel, i+1, path)
            #最后要加pop
            path.pop()